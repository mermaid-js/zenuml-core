/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

 
import * as langium from "langium";

export const SequenceTerminals = {
  STRING: /"[^"]*"/,
  FLOAT: /[0-9]+\.[0-9]+/,
  INT: /[0-9]+/,
  MONEY: /\$[0-9]+(\.[0-9]+)?/,
  NUMBER_UNIT: /([0-9]+(\.[0-9]+)?)[a-zA-Z]+/,
  COLOR: /#[0-9a-fA-F]+/,
  BOOLEAN: /true|false/,
  DIVIDER: /==[^\r\n]*/,
  ID: /[a-zA-Z_][a-zA-Z_0-9]*/,
  ANNOTATION: /@(?!(Return|return|Reply|reply))[a-zA-Z_][a-zA-Z_0-9]*/,
  ANNOTATION_RET: /@(Return|return|Reply|reply)/,
  SL_COMMENT: /\/\/[^\r\n]*/,
  WS: /\s+/,
  ML_COMMENT: /\/\*[\s\S]*?\*\//,
};

export type SequenceTerminalNames = keyof typeof SequenceTerminals;

export type SequenceKeywordNames =
  | "!"
  | "!="
  | "%"
  | "&&"
  | "("
  | ")"
  | "*"
  | "+"
  | ","
  | "-"
  | "->"
  | "."
  | "/"
  | ":"
  | ";"
  | "<"
  | "<<"
  | "<="
  | "="
  | "=="
  | ">"
  | ">="
  | ">>"
  | "@Starter"
  | "@starter"
  | "RET"
  | "ReturnType"
  | "^"
  | "as"
  | "async"
  | "await"
  | "catch"
  | "const"
  | "critical"
  | "else"
  | "finally"
  | "forEach"
  | "foreach"
  | "group"
  | "if"
  | "in"
  | "loop"
  | "new"
  | "nil"
  | "null"
  | "opt"
  | "par"
  | "readonly"
  | "ref"
  | "return"
  | "section"
  | "static"
  | "title"
  | "try"
  | "var"
  | "while"
  | "{"
  | "||"
  | "}";

export type SequenceTokenNames = SequenceTerminalNames | SequenceKeywordNames;

export type Atom =
  | BooleanAtom
  | IdAtom
  | MoneyAtom
  | NilAtom
  | NumberAtom
  | NumberUnitAtom
  | StringAtom;

export const Atom = "Atom";

export function isAtom(item: unknown): item is Atom {
  return reflection.isInstance(item, Atom);
}

export type Condition = Atom | InExpression;

export const Condition = "Condition";

export function isCondition(item: unknown): item is Condition {
  return reflection.isInstance(item, Condition);
}

export type Expression = AtomicExpression | BinaryExpression | UnaryExpression;

export const Expression = "Expression";

export function isExpression(item: unknown): item is Expression {
  return reflection.isInstance(item, Expression);
}

export type Modifier =
  | "RET"
  | "ReturnType"
  | "async"
  | "await"
  | "const"
  | "readonly"
  | "static"
  | "var";

export function isModifier(item: unknown): item is Modifier {
  return (
    item === "const" ||
    item === "readonly" ||
    item === "static" ||
    item === "await" ||
    item === "async" ||
    item === "var" ||
    item === "RET" ||
    item === "ReturnType"
  );
}

export type Operator =
  | "!="
  | "%"
  | "&&"
  | "*"
  | "+"
  | "-"
  | "/"
  | "<"
  | "<="
  | "=="
  | ">"
  | ">="
  | "^"
  | "||";

export function isOperator(item: unknown): item is Operator {
  return (
    item === "+" ||
    item === "-" ||
    item === "*" ||
    item === "/" ||
    item === "%" ||
    item === "^" ||
    item === "==" ||
    item === "!=" ||
    item === ">" ||
    item === "<" ||
    item === ">=" ||
    item === "<=" ||
    item === "&&" ||
    item === "||"
  );
}

export type Parameter = Declaration | Expression;

export const Parameter = "Parameter";

export function isParameter(item: unknown): item is Parameter {
  return reflection.isInstance(item, Parameter);
}

export type Statement =
  | Alt
  | AssignmentStatement
  | AsyncMessage
  | Comment
  | Creation
  | Critical
  | Divider
  | FunctionCallStatement
  | Loop
  | MessageCall
  | Opt
  | Par
  | Ref
  | Ret
  | Section
  | TCF;

export const Statement = "Statement";

export function isStatement(item: unknown): item is Statement {
  return reflection.isInstance(item, Statement);
}

export interface Alt extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Alt";
  elseBlock?: ElseBlock;
  elseIfBlocks: Array<ElseIfBlock>;
  ifBlock: IfBlock;
}

export const Alt = "Alt";

export function isAlt(item: unknown): item is Alt {
  return reflection.isInstance(item, Alt);
}

export interface Assignment extends langium.AstNode {
  readonly $container: AssignmentStatement;
  readonly $type: "Assignment";
  assignee: string;
  modifiers: Array<Modifier>;
  type?: Type;
  value?: Expression;
}

export const Assignment = "Assignment";

export function isAssignment(item: unknown): item is Assignment {
  return reflection.isInstance(item, Assignment);
}

export interface AssignmentStatement extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "AssignmentStatement";
  assignment: Assignment;
  block?: BraceBlock;
}

export const AssignmentStatement = "AssignmentStatement";

export function isAssignmentStatement(
  item: unknown,
): item is AssignmentStatement {
  return reflection.isInstance(item, AssignmentStatement);
}

export interface AsyncMessage extends langium.AstNode {
  readonly $container: Block | Ret;
  readonly $type: "AsyncMessage";
  content?: Content;
  from?: From;
  to: To;
}

export const AsyncMessage = "AsyncMessage";

export function isAsyncMessage(item: unknown): item is AsyncMessage {
  return reflection.isInstance(item, AsyncMessage);
}

export interface AtomicExpression extends langium.AstNode {
  readonly $type:
    | "Atom"
    | "AtomicExpression"
    | "BooleanAtom"
    | "CreationExpression"
    | "FuncExpression"
    | "IdAtom"
    | "MoneyAtom"
    | "NilAtom"
    | "NumberAtom"
    | "NumberUnitAtom"
    | "SelfFuncExpression"
    | "StringAtom";
  expr: Expression;
}

export const AtomicExpression = "AtomicExpression";

export function isAtomicExpression(item: unknown): item is AtomicExpression {
  return reflection.isInstance(item, AtomicExpression);
}

export interface BinaryExpression extends langium.AstNode {
  readonly $container: Assignment | AtomicExpression | Parameters | Ret;
  readonly $type: "BinaryExpression";
  left: AtomicExpression;
  op: Operator;
  right: AtomicExpression;
}

export const BinaryExpression = "BinaryExpression";

export function isBinaryExpression(item: unknown): item is BinaryExpression {
  return reflection.isInstance(item, BinaryExpression);
}

export interface Block extends langium.AstNode {
  readonly $container: BraceBlock | Model;
  readonly $type: "Block";
  statements: Array<Statement>;
}

export const Block = "Block";

export function isBlock(item: unknown): item is Block {
  return reflection.isInstance(item, Block);
}

export interface BooleanAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "BooleanAtom";
  value: string;
}

export const BooleanAtom = "BooleanAtom";

export function isBooleanAtom(item: unknown): item is BooleanAtom {
  return reflection.isInstance(item, BooleanAtom);
}

export interface BraceBlock extends langium.AstNode {
  readonly $container:
    | AssignmentStatement
    | CatchBlock
    | Creation
    | CreationExpression
    | Critical
    | ElseBlock
    | ElseIfBlock
    | FinallyBlock
    | FunctionCallStatement
    | IfBlock
    | Loop
    | MessageCall
    | Opt
    | Par
    | Section
    | TryBlock;
  readonly $type: "BraceBlock";
  block?: Block;
}

export const BraceBlock = "BraceBlock";

export function isBraceBlock(item: unknown): item is BraceBlock {
  return reflection.isInstance(item, BraceBlock);
}

export interface CatchBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "CatchBlock";
  block: BraceBlock;
  invocation?: Invocation;
}

export const CatchBlock = "CatchBlock";

export function isCatchBlock(item: unknown): item is CatchBlock {
  return reflection.isInstance(item, CatchBlock);
}

export interface Comment extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Comment";
  value: string;
}

export const Comment = "Comment";

export function isComment(item: unknown): item is Comment {
  return reflection.isInstance(item, Comment);
}

export interface ConditionalExpression extends langium.AstNode {
  readonly $container: ElseIfBlock | IfBlock | Loop;
  readonly $type: "ConditionalExpression";
  condition?: Condition;
}

export const ConditionalExpression = "ConditionalExpression";

export function isConditionalExpression(
  item: unknown,
): item is ConditionalExpression {
  return reflection.isInstance(item, ConditionalExpression);
}

export interface Construct extends langium.AstNode {
  readonly $container: CreationBody;
  readonly $type: "Construct";
  value: string;
}

export const Construct = "Construct";

export function isConstruct(item: unknown): item is Construct {
  return reflection.isInstance(item, Construct);
}

export interface Content extends langium.AstNode {
  readonly $container: AsyncMessage;
  readonly $type: "Content";
  value: string;
}

export const Content = "Content";

export function isContent(item: unknown): item is Content {
  return reflection.isInstance(item, Content);
}

export interface Creation extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Creation";
  block?: BraceBlock;
  body: CreationBody;
}

export const Creation = "Creation";

export function isCreation(item: unknown): item is Creation {
  return reflection.isInstance(item, Creation);
}

export interface CreationBody extends langium.AstNode {
  readonly $container: Creation;
  readonly $type: "CreationBody";
  assignee?: string;
  construct?: Construct;
  parameters?: Parameters;
}

export const CreationBody = "CreationBody";

export function isCreationBody(item: unknown): item is CreationBody {
  return reflection.isInstance(item, CreationBody);
}

export interface Critical extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Critical";
  atom?: Atom;
  block?: BraceBlock;
}

export const Critical = "Critical";

export function isCritical(item: unknown): item is Critical {
  return reflection.isInstance(item, Critical);
}

export interface Declaration extends langium.AstNode {
  readonly $container: Parameters;
  readonly $type: "Declaration";
  name: string;
  type: Type;
}

export const Declaration = "Declaration";

export function isDeclaration(item: unknown): item is Declaration {
  return reflection.isInstance(item, Declaration);
}

export interface Divider extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Divider";
  note: DividerNote;
}

export const Divider = "Divider";

export function isDivider(item: unknown): item is Divider {
  return reflection.isInstance(item, Divider);
}

export interface DividerNote extends langium.AstNode {
  readonly $container: Divider;
  readonly $type: "DividerNote";
  content: string;
}

export const DividerNote = "DividerNote";

export function isDividerNote(item: unknown): item is DividerNote {
  return reflection.isInstance(item, DividerNote);
}

export interface ElseBlock extends langium.AstNode {
  readonly $container: Alt;
  readonly $type: "ElseBlock";
  block: BraceBlock;
}

export const ElseBlock = "ElseBlock";

export function isElseBlock(item: unknown): item is ElseBlock {
  return reflection.isInstance(item, ElseBlock);
}

export interface ElseIfBlock extends langium.AstNode {
  readonly $container: Alt;
  readonly $type: "ElseIfBlock";
  block: BraceBlock;
  condition: ConditionalExpression;
}

export const ElseIfBlock = "ElseIfBlock";

export function isElseIfBlock(item: unknown): item is ElseIfBlock {
  return reflection.isInstance(item, ElseIfBlock);
}

export interface FinallyBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "FinallyBlock";
  block: BraceBlock;
}

export const FinallyBlock = "FinallyBlock";

export function isFinallyBlock(item: unknown): item is FinallyBlock {
  return reflection.isInstance(item, FinallyBlock);
}

export interface From extends langium.AstNode {
  readonly $container: AsyncMessage | FuncExpression | MessageCall;
  readonly $type: "From";
  value: string;
}

export const From = "From";

export function isFrom(item: unknown): item is From {
  return reflection.isInstance(item, From);
}

export interface Func extends langium.AstNode {
  readonly $container:
    | FuncExpression
    | FunctionCallStatement
    | MessageCall
    | SelfFuncExpression;
  readonly $type: "Func";
  signatures: Array<Signature>;
}

export const Func = "Func";

export function isFunc(item: unknown): item is Func {
  return reflection.isInstance(item, Func);
}

export interface FunctionCallStatement extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "FunctionCallStatement";
  block?: BraceBlock;
  func: Func;
}

export const FunctionCallStatement = "FunctionCallStatement";

export function isFunctionCallStatement(
  item: unknown,
): item is FunctionCallStatement {
  return reflection.isInstance(item, FunctionCallStatement);
}

export interface Group extends langium.AstNode {
  readonly $container: Header;
  readonly $type: "Group";
  name?: Name;
  participants: Array<Participant>;
}

export const Group = "Group";

export function isGroup(item: unknown): item is Group {
  return reflection.isInstance(item, Group);
}

export interface Head extends langium.AstNode {
  readonly $container: Model;
  readonly $type: "Head";
  headers: Array<Header>;
  starterExp?: StarterExpression;
}

export const Head = "Head";

export function isHead(item: unknown): item is Head {
  return reflection.isInstance(item, Head);
}

export interface Header extends langium.AstNode {
  readonly $container: Head;
  readonly $type: "Header";
  group?: Group;
  participant?: Participant;
}

export const Header = "Header";

export function isHeader(item: unknown): item is Header {
  return reflection.isInstance(item, Header);
}

export interface IdAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "IdAtom";
  value: string;
}

export const IdAtom = "IdAtom";

export function isIdAtom(item: unknown): item is IdAtom {
  return reflection.isInstance(item, IdAtom);
}

export interface IfBlock extends langium.AstNode {
  readonly $container: Alt;
  readonly $type: "IfBlock";
  block: BraceBlock;
  condition: ConditionalExpression;
}

export const IfBlock = "IfBlock";

export function isIfBlock(item: unknown): item is IfBlock {
  return reflection.isInstance(item, IfBlock);
}

export interface InExpression extends langium.AstNode {
  readonly $container: ConditionalExpression;
  readonly $type: "InExpression";
  left: string;
  right: string;
}

export const InExpression = "InExpression";

export function isInExpression(item: unknown): item is InExpression {
  return reflection.isInstance(item, InExpression);
}

export interface Invocation extends langium.AstNode {
  readonly $container: CatchBlock | Signature;
  readonly $type: "Invocation";
  parameters?: Parameters;
}

export const Invocation = "Invocation";

export function isInvocation(item: unknown): item is Invocation {
  return reflection.isInstance(item, Invocation);
}

export interface Label extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "Label";
  name?: Name;
}

export const Label = "Label";

export function isLabel(item: unknown): item is Label {
  return reflection.isInstance(item, Label);
}

export interface Loop extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Loop";
  block?: BraceBlock;
  condition: ConditionalExpression;
}

export const Loop = "Loop";

export function isLoop(item: unknown): item is Loop {
  return reflection.isInstance(item, Loop);
}

export interface MessageCall extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "MessageCall";
  block?: BraceBlock;
  from?: From;
  func?: Func;
  to: To;
}

export const MessageCall = "MessageCall";

export function isMessageCall(item: unknown): item is MessageCall {
  return reflection.isInstance(item, MessageCall);
}

export interface MethodName extends langium.AstNode {
  readonly $container: Signature;
  readonly $type: "MethodName";
  value: string;
}

export const MethodName = "MethodName";

export function isMethodName(item: unknown): item is MethodName {
  return reflection.isInstance(item, MethodName);
}

export interface Model extends langium.AstNode {
  readonly $type: "Model";
  block?: Block;
  head?: Head;
  leadingComments: Array<string>;
  title?: Title;
}

export const Model = "Model";

export function isModel(item: unknown): item is Model {
  return reflection.isInstance(item, Model);
}

export interface MoneyAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "MoneyAtom";
  value: string;
}

export const MoneyAtom = "MoneyAtom";

export function isMoneyAtom(item: unknown): item is MoneyAtom {
  return reflection.isInstance(item, MoneyAtom);
}

export interface Name extends langium.AstNode {
  readonly $container: Group | Label | Participant | Ref | Stereotype | Title;
  readonly $type: "Name";
  value: string;
}

export const Name = "Name";

export function isName(item: unknown): item is Name {
  return reflection.isInstance(item, Name);
}

export interface NilAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "NilAtom";
  value: "nil" | "null";
}

export const NilAtom = "NilAtom";

export function isNilAtom(item: unknown): item is NilAtom {
  return reflection.isInstance(item, NilAtom);
}

export interface NumberAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "NumberAtom";
  value: string;
}

export const NumberAtom = "NumberAtom";

export function isNumberAtom(item: unknown): item is NumberAtom {
  return reflection.isInstance(item, NumberAtom);
}

export interface NumberUnitAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "NumberUnitAtom";
  value: string;
}

export const NumberUnitAtom = "NumberUnitAtom";

export function isNumberUnitAtom(item: unknown): item is NumberUnitAtom {
  return reflection.isInstance(item, NumberUnitAtom);
}

export interface Opt extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Opt";
  block?: BraceBlock;
}

export const Opt = "Opt";

export function isOpt(item: unknown): item is Opt {
  return reflection.isInstance(item, Opt);
}

export interface Par extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Par";
  block?: BraceBlock;
}

export const Par = "Par";

export function isPar(item: unknown): item is Par {
  return reflection.isInstance(item, Par);
}

export interface Parameters extends langium.AstNode {
  readonly $container: CreationBody | CreationExpression | Invocation;
  readonly $type: "Parameters";
  parameters: Array<Parameter>;
}

export const Parameters = "Parameters";

export function isParameters(item: unknown): item is Parameters {
  return reflection.isInstance(item, Parameters);
}

export interface Participant extends langium.AstNode {
  readonly $container: Group | Header;
  readonly $type: "Participant";
  color?: string;
  label?: Label;
  name?: Name;
  stereotype?: Stereotype;
  type?: ParticipantType;
  width?: Width;
}

export const Participant = "Participant";

export function isParticipant(item: unknown): item is Participant {
  return reflection.isInstance(item, Participant);
}

export interface ParticipantType extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "ParticipantType";
  type: string;
}

export const ParticipantType = "ParticipantType";

export function isParticipantType(item: unknown): item is ParticipantType {
  return reflection.isInstance(item, ParticipantType);
}

export interface Ref extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Ref";
  names: Array<Name>;
}

export const Ref = "Ref";

export function isRef(item: unknown): item is Ref {
  return reflection.isInstance(item, Ref);
}

export interface Ret extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Ret";
  annotation?: string;
  asyncMessage?: AsyncMessage;
  expr?: Expression;
}

export const Ret = "Ret";

export function isRet(item: unknown): item is Ret {
  return reflection.isInstance(item, Ret);
}

export interface Section extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Section";
  atom?: Atom;
  block?: BraceBlock;
}

export const Section = "Section";

export function isSection(item: unknown): item is Section {
  return reflection.isInstance(item, Section);
}

export interface Signature extends langium.AstNode {
  readonly $container: Func;
  readonly $type: "Signature";
  invocation?: Invocation;
  methodName: MethodName;
}

export const Signature = "Signature";

export function isSignature(item: unknown): item is Signature {
  return reflection.isInstance(item, Signature);
}

export interface Starter extends langium.AstNode {
  readonly $container: StarterExpression;
  readonly $type: "Starter";
  value: string;
}

export const Starter = "Starter";

export function isStarter(item: unknown): item is Starter {
  return reflection.isInstance(item, Starter);
}

export interface StarterExpression extends langium.AstNode {
  readonly $container: Head;
  readonly $type: "StarterExpression";
  annotation?: string;
  starter?: Starter;
}

export const StarterExpression = "StarterExpression";

export function isStarterExpression(item: unknown): item is StarterExpression {
  return reflection.isInstance(item, StarterExpression);
}

export interface Stereotype extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "Stereotype";
  name?: Name;
}

export const Stereotype = "Stereotype";

export function isStereotype(item: unknown): item is Stereotype {
  return reflection.isInstance(item, Stereotype);
}

export interface StringAtom extends langium.AstNode {
  readonly $container: ConditionalExpression | Critical | Section;
  readonly $type: "StringAtom";
  value: string;
}

export const StringAtom = "StringAtom";

export function isStringAtom(item: unknown): item is StringAtom {
  return reflection.isInstance(item, StringAtom);
}

export interface TCF extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "TCF";
  catchBlocks: Array<CatchBlock>;
  finallyBlock?: FinallyBlock;
  tryBlock: TryBlock;
}

export const TCF = "TCF";

export function isTCF(item: unknown): item is TCF {
  return reflection.isInstance(item, TCF);
}

export interface Title extends langium.AstNode {
  readonly $container: Model;
  readonly $type: "Title";
  content?: Name;
}

export const Title = "Title";

export function isTitle(item: unknown): item is Title {
  return reflection.isInstance(item, Title);
}

export interface To extends langium.AstNode {
  readonly $container: AsyncMessage | FuncExpression | MessageCall;
  readonly $type: "To";
  value: string;
}

export const To = "To";

export function isTo(item: unknown): item is To {
  return reflection.isInstance(item, To);
}

export interface TryBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "TryBlock";
  block: BraceBlock;
}

export const TryBlock = "TryBlock";

export function isTryBlock(item: unknown): item is TryBlock {
  return reflection.isInstance(item, TryBlock);
}

export interface Type extends langium.AstNode {
  readonly $container: Assignment | CreationExpression | Declaration;
  readonly $type: "Type";
  value: string;
}

export const Type = "Type";

export function isType(item: unknown): item is Type {
  return reflection.isInstance(item, Type);
}

export interface UnaryExpression extends langium.AstNode {
  readonly $container: Assignment | AtomicExpression | Parameters | Ret;
  readonly $type: "UnaryExpression";
  expr: AtomicExpression;
  op: "!" | "-";
}

export const UnaryExpression = "UnaryExpression";

export function isUnaryExpression(item: unknown): item is UnaryExpression {
  return reflection.isInstance(item, UnaryExpression);
}

export interface Width extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "Width";
  value: string;
}

export const Width = "Width";

export function isWidth(item: unknown): item is Width {
  return reflection.isInstance(item, Width);
}

export interface CreationExpression extends AtomicExpression {
  readonly $type: "CreationExpression";
  block?: BraceBlock;
  constructor?: Type;
  params?: Parameters;
}

export const CreationExpression = "CreationExpression";

export function isCreationExpression(
  item: unknown,
): item is CreationExpression {
  return reflection.isInstance(item, CreationExpression);
}

export interface FuncExpression extends AtomicExpression {
  readonly $type: "FuncExpression";
  from?: From;
  func?: Func;
  to: To;
}

export const FuncExpression = "FuncExpression";

export function isFuncExpression(item: unknown): item is FuncExpression {
  return reflection.isInstance(item, FuncExpression);
}

export interface SelfFuncExpression extends AtomicExpression {
  readonly $type: "SelfFuncExpression";
  func: Func;
}

export const SelfFuncExpression = "SelfFuncExpression";

export function isSelfFuncExpression(
  item: unknown,
): item is SelfFuncExpression {
  return reflection.isInstance(item, SelfFuncExpression);
}

export type SequenceAstType = {
  Alt: Alt;
  Assignment: Assignment;
  AssignmentStatement: AssignmentStatement;
  AsyncMessage: AsyncMessage;
  Atom: Atom;
  AtomicExpression: AtomicExpression;
  BinaryExpression: BinaryExpression;
  Block: Block;
  BooleanAtom: BooleanAtom;
  BraceBlock: BraceBlock;
  CatchBlock: CatchBlock;
  Comment: Comment;
  Condition: Condition;
  ConditionalExpression: ConditionalExpression;
  Construct: Construct;
  Content: Content;
  Creation: Creation;
  CreationBody: CreationBody;
  CreationExpression: CreationExpression;
  Critical: Critical;
  Declaration: Declaration;
  Divider: Divider;
  DividerNote: DividerNote;
  ElseBlock: ElseBlock;
  ElseIfBlock: ElseIfBlock;
  Expression: Expression;
  FinallyBlock: FinallyBlock;
  From: From;
  Func: Func;
  FuncExpression: FuncExpression;
  FunctionCallStatement: FunctionCallStatement;
  Group: Group;
  Head: Head;
  Header: Header;
  IdAtom: IdAtom;
  IfBlock: IfBlock;
  InExpression: InExpression;
  Invocation: Invocation;
  Label: Label;
  Loop: Loop;
  MessageCall: MessageCall;
  MethodName: MethodName;
  Model: Model;
  MoneyAtom: MoneyAtom;
  Name: Name;
  NilAtom: NilAtom;
  NumberAtom: NumberAtom;
  NumberUnitAtom: NumberUnitAtom;
  Opt: Opt;
  Par: Par;
  Parameter: Parameter;
  Parameters: Parameters;
  Participant: Participant;
  ParticipantType: ParticipantType;
  Ref: Ref;
  Ret: Ret;
  Section: Section;
  SelfFuncExpression: SelfFuncExpression;
  Signature: Signature;
  Starter: Starter;
  StarterExpression: StarterExpression;
  Statement: Statement;
  Stereotype: Stereotype;
  StringAtom: StringAtom;
  TCF: TCF;
  Title: Title;
  To: To;
  TryBlock: TryBlock;
  Type: Type;
  UnaryExpression: UnaryExpression;
  Width: Width;
};

export class SequenceAstReflection extends langium.AbstractAstReflection {
  getAllTypes(): string[] {
    return [
      Alt,
      Assignment,
      AssignmentStatement,
      AsyncMessage,
      Atom,
      AtomicExpression,
      BinaryExpression,
      Block,
      BooleanAtom,
      BraceBlock,
      CatchBlock,
      Comment,
      Condition,
      ConditionalExpression,
      Construct,
      Content,
      Creation,
      CreationBody,
      CreationExpression,
      Critical,
      Declaration,
      Divider,
      DividerNote,
      ElseBlock,
      ElseIfBlock,
      Expression,
      FinallyBlock,
      From,
      Func,
      FuncExpression,
      FunctionCallStatement,
      Group,
      Head,
      Header,
      IdAtom,
      IfBlock,
      InExpression,
      Invocation,
      Label,
      Loop,
      MessageCall,
      MethodName,
      Model,
      MoneyAtom,
      Name,
      NilAtom,
      NumberAtom,
      NumberUnitAtom,
      Opt,
      Par,
      Parameter,
      Parameters,
      Participant,
      ParticipantType,
      Ref,
      Ret,
      Section,
      SelfFuncExpression,
      Signature,
      Starter,
      StarterExpression,
      Statement,
      Stereotype,
      StringAtom,
      TCF,
      Title,
      To,
      TryBlock,
      Type,
      UnaryExpression,
      Width,
    ];
  }

  protected override computeIsSubtype(
    subtype: string,
    supertype: string,
  ): boolean {
    switch (subtype) {
      case Alt:
      case AssignmentStatement:
      case AsyncMessage:
      case Comment:
      case Creation:
      case Critical:
      case Divider:
      case FunctionCallStatement:
      case Loop:
      case MessageCall:
      case Opt:
      case Par:
      case Ref:
      case Ret:
      case Section:
      case TCF: {
        return this.isSubtype(Statement, supertype);
      }
      case Atom: {
        return (
          this.isSubtype(AtomicExpression, supertype) ||
          this.isSubtype(Condition, supertype)
        );
      }
      case AtomicExpression:
      case BinaryExpression:
      case UnaryExpression: {
        return this.isSubtype(Expression, supertype);
      }
      case BooleanAtom:
      case IdAtom:
      case MoneyAtom:
      case NilAtom:
      case NumberAtom:
      case NumberUnitAtom:
      case StringAtom: {
        return this.isSubtype(Atom, supertype);
      }
      case CreationExpression:
      case FuncExpression:
      case SelfFuncExpression: {
        return this.isSubtype(AtomicExpression, supertype);
      }
      case Declaration:
      case Expression: {
        return this.isSubtype(Parameter, supertype);
      }
      case InExpression: {
        return this.isSubtype(Condition, supertype);
      }
      default: {
        return false;
      }
    }
  }

  getReferenceType(refInfo: langium.ReferenceInfo): string {
    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
    switch (referenceId) {
      default: {
        throw new Error(`${referenceId} is not a valid reference id.`);
      }
    }
  }

  getTypeMetaData(type: string): langium.TypeMetaData {
    switch (type) {
      case Alt: {
        return {
          name: Alt,
          properties: [
            { name: "elseBlock" },
            { name: "elseIfBlocks", defaultValue: [] },
            { name: "ifBlock" },
          ],
        };
      }
      case Assignment: {
        return {
          name: Assignment,
          properties: [
            { name: "assignee" },
            { name: "modifiers", defaultValue: [] },
            { name: "type" },
            { name: "value" },
          ],
        };
      }
      case AssignmentStatement: {
        return {
          name: AssignmentStatement,
          properties: [{ name: "assignment" }, { name: "block" }],
        };
      }
      case AsyncMessage: {
        return {
          name: AsyncMessage,
          properties: [{ name: "content" }, { name: "from" }, { name: "to" }],
        };
      }
      case AtomicExpression: {
        return {
          name: AtomicExpression,
          properties: [{ name: "expr" }],
        };
      }
      case BinaryExpression: {
        return {
          name: BinaryExpression,
          properties: [{ name: "left" }, { name: "op" }, { name: "right" }],
        };
      }
      case Block: {
        return {
          name: Block,
          properties: [{ name: "statements", defaultValue: [] }],
        };
      }
      case BooleanAtom: {
        return {
          name: BooleanAtom,
          properties: [{ name: "value" }],
        };
      }
      case BraceBlock: {
        return {
          name: BraceBlock,
          properties: [{ name: "block" }],
        };
      }
      case CatchBlock: {
        return {
          name: CatchBlock,
          properties: [{ name: "block" }, { name: "invocation" }],
        };
      }
      case Comment: {
        return {
          name: Comment,
          properties: [{ name: "value" }],
        };
      }
      case ConditionalExpression: {
        return {
          name: ConditionalExpression,
          properties: [{ name: "condition" }],
        };
      }
      case Construct: {
        return {
          name: Construct,
          properties: [{ name: "value" }],
        };
      }
      case Content: {
        return {
          name: Content,
          properties: [{ name: "value" }],
        };
      }
      case Creation: {
        return {
          name: Creation,
          properties: [{ name: "block" }, { name: "body" }],
        };
      }
      case CreationBody: {
        return {
          name: CreationBody,
          properties: [
            { name: "assignee" },
            { name: "construct" },
            { name: "parameters" },
          ],
        };
      }
      case Critical: {
        return {
          name: Critical,
          properties: [{ name: "atom" }, { name: "block" }],
        };
      }
      case Declaration: {
        return {
          name: Declaration,
          properties: [{ name: "name" }, { name: "type" }],
        };
      }
      case Divider: {
        return {
          name: Divider,
          properties: [{ name: "note" }],
        };
      }
      case DividerNote: {
        return {
          name: DividerNote,
          properties: [{ name: "content" }],
        };
      }
      case ElseBlock: {
        return {
          name: ElseBlock,
          properties: [{ name: "block" }],
        };
      }
      case ElseIfBlock: {
        return {
          name: ElseIfBlock,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case FinallyBlock: {
        return {
          name: FinallyBlock,
          properties: [{ name: "block" }],
        };
      }
      case From: {
        return {
          name: From,
          properties: [{ name: "value" }],
        };
      }
      case Func: {
        return {
          name: Func,
          properties: [{ name: "signatures", defaultValue: [] }],
        };
      }
      case FunctionCallStatement: {
        return {
          name: FunctionCallStatement,
          properties: [{ name: "block" }, { name: "func" }],
        };
      }
      case Group: {
        return {
          name: Group,
          properties: [
            { name: "name" },
            { name: "participants", defaultValue: [] },
          ],
        };
      }
      case Head: {
        return {
          name: Head,
          properties: [
            { name: "headers", defaultValue: [] },
            { name: "starterExp" },
          ],
        };
      }
      case Header: {
        return {
          name: Header,
          properties: [{ name: "group" }, { name: "participant" }],
        };
      }
      case IdAtom: {
        return {
          name: IdAtom,
          properties: [{ name: "value" }],
        };
      }
      case IfBlock: {
        return {
          name: IfBlock,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case InExpression: {
        return {
          name: InExpression,
          properties: [{ name: "left" }, { name: "right" }],
        };
      }
      case Invocation: {
        return {
          name: Invocation,
          properties: [{ name: "parameters" }],
        };
      }
      case Label: {
        return {
          name: Label,
          properties: [{ name: "name" }],
        };
      }
      case Loop: {
        return {
          name: Loop,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case MessageCall: {
        return {
          name: MessageCall,
          properties: [
            { name: "block" },
            { name: "from" },
            { name: "func" },
            { name: "to" },
          ],
        };
      }
      case MethodName: {
        return {
          name: MethodName,
          properties: [{ name: "value" }],
        };
      }
      case Model: {
        return {
          name: Model,
          properties: [
            { name: "block" },
            { name: "head" },
            { name: "leadingComments", defaultValue: [] },
            { name: "title" },
          ],
        };
      }
      case MoneyAtom: {
        return {
          name: MoneyAtom,
          properties: [{ name: "value" }],
        };
      }
      case Name: {
        return {
          name: Name,
          properties: [{ name: "value" }],
        };
      }
      case NilAtom: {
        return {
          name: NilAtom,
          properties: [{ name: "value" }],
        };
      }
      case NumberAtom: {
        return {
          name: NumberAtom,
          properties: [{ name: "value" }],
        };
      }
      case NumberUnitAtom: {
        return {
          name: NumberUnitAtom,
          properties: [{ name: "value" }],
        };
      }
      case Opt: {
        return {
          name: Opt,
          properties: [{ name: "block" }],
        };
      }
      case Par: {
        return {
          name: Par,
          properties: [{ name: "block" }],
        };
      }
      case Parameters: {
        return {
          name: Parameters,
          properties: [{ name: "parameters", defaultValue: [] }],
        };
      }
      case Participant: {
        return {
          name: Participant,
          properties: [
            { name: "color" },
            { name: "label" },
            { name: "name" },
            { name: "stereotype" },
            { name: "type" },
            { name: "width" },
          ],
        };
      }
      case ParticipantType: {
        return {
          name: ParticipantType,
          properties: [{ name: "type" }],
        };
      }
      case Ref: {
        return {
          name: Ref,
          properties: [{ name: "names", defaultValue: [] }],
        };
      }
      case Ret: {
        return {
          name: Ret,
          properties: [
            { name: "annotation" },
            { name: "asyncMessage" },
            { name: "expr" },
          ],
        };
      }
      case Section: {
        return {
          name: Section,
          properties: [{ name: "atom" }, { name: "block" }],
        };
      }
      case Signature: {
        return {
          name: Signature,
          properties: [{ name: "invocation" }, { name: "methodName" }],
        };
      }
      case Starter: {
        return {
          name: Starter,
          properties: [{ name: "value" }],
        };
      }
      case StarterExpression: {
        return {
          name: StarterExpression,
          properties: [{ name: "annotation" }, { name: "starter" }],
        };
      }
      case Stereotype: {
        return {
          name: Stereotype,
          properties: [{ name: "name" }],
        };
      }
      case StringAtom: {
        return {
          name: StringAtom,
          properties: [{ name: "value" }],
        };
      }
      case TCF: {
        return {
          name: TCF,
          properties: [
            { name: "catchBlocks", defaultValue: [] },
            { name: "finallyBlock" },
            { name: "tryBlock" },
          ],
        };
      }
      case Title: {
        return {
          name: Title,
          properties: [{ name: "content" }],
        };
      }
      case To: {
        return {
          name: To,
          properties: [{ name: "value" }],
        };
      }
      case TryBlock: {
        return {
          name: TryBlock,
          properties: [{ name: "block" }],
        };
      }
      case Type: {
        return {
          name: Type,
          properties: [{ name: "value" }],
        };
      }
      case UnaryExpression: {
        return {
          name: UnaryExpression,
          properties: [{ name: "expr" }, { name: "op" }],
        };
      }
      case Width: {
        return {
          name: Width,
          properties: [{ name: "value" }],
        };
      }
      case CreationExpression: {
        return {
          name: CreationExpression,
          properties: [
            { name: "block" },
            { name: "constructor" },
            { name: "expr" },
            { name: "params" },
          ],
        };
      }
      case FuncExpression: {
        return {
          name: FuncExpression,
          properties: [
            { name: "expr" },
            { name: "from" },
            { name: "func" },
            { name: "to" },
          ],
        };
      }
      case SelfFuncExpression: {
        return {
          name: SelfFuncExpression,
          properties: [{ name: "expr" }, { name: "func" }],
        };
      }
      default: {
        return {
          name: type,
          properties: [],
        };
      }
    }
  }
}

export const reflection = new SequenceAstReflection();
