/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

 
import * as langium from "langium";

export const SequenceTerminals = {
  STRING: /"[^"]*"/,
  FLOAT: /[0-9]+\.[0-9]+/,
  INT: /[0-9]+/,
  MONEY: /\$[0-9]+(\.[0-9]+)?/,
  BOOLEAN: /true|false/,
  ID: /[a-zA-Z_][a-zA-Z_0-9]*/,
  ANNOTATION: /@[a-zA-Z_][a-zA-Z_0-9]*/,
  WS: /\s+/,
  ML_COMMENT: /\/\*[\s\S]*?\*\//,
  SL_COMMENT: /\/\/[^\r\n]*/,
};

export type SequenceTerminalNames = keyof typeof SequenceTerminals;

export type SequenceKeywordNames =
  | "!="
  | "%"
  | "&&"
  | "("
  | ")"
  | "*"
  | "+"
  | ","
  | "-"
  | "->"
  | "."
  | "/"
  | ":"
  | ";"
  | "<"
  | "<<"
  | "<="
  | "="
  | "=="
  | ">"
  | ">="
  | ">>"
  | "@"
  | "Starter"
  | "^"
  | "as"
  | "catch"
  | "critical"
  | "else"
  | "finally"
  | "group"
  | "if"
  | "new"
  | "opt"
  | "par"
  | "ref"
  | "section"
  | "starter"
  | "title"
  | "try"
  | "while"
  | "{"
  | "||"
  | "}";

export type SequenceTokenNames = SequenceTerminalNames | SequenceKeywordNames;

export type Alt = ElseBlock | ElseIfBlock | IfBlock;

export const Alt = "Alt";

export function isAlt(item: unknown): item is Alt {
  return reflection.isInstance(item, Alt);
}

export type Expression = BinaryExpr | Primary;

export const Expression = "Expression";

export function isExpression(item: unknown): item is Expression {
  return reflection.isInstance(item, Expression);
}

export type Operator =
  | "!="
  | "%"
  | "&&"
  | "*"
  | "+"
  | "-"
  | "/"
  | "<"
  | "<="
  | "=="
  | ">"
  | ">="
  | "^"
  | "||";

export function isOperator(item: unknown): item is Operator {
  return (
    item === "+" ||
    item === "-" ||
    item === "*" ||
    item === "/" ||
    item === "%" ||
    item === "^" ||
    item === "==" ||
    item === "!=" ||
    item === ">" ||
    item === "<" ||
    item === ">=" ||
    item === "<=" ||
    item === "&&" ||
    item === "||"
  );
}

export type Parameter = Declaration | Expression;

export const Parameter = "Parameter";

export function isParameter(item: unknown): item is Parameter {
  return reflection.isInstance(item, Parameter);
}

export type Statement =
  | Alt
  | AsyncMessage
  | Creation
  | Critical
  | Loop
  | Message
  | Opt
  | Par
  | Ref
  | Section
  | TCF;

export const Statement = "Statement";

export function isStatement(item: unknown): item is Statement {
  return reflection.isInstance(item, Statement);
}

export interface Assignment extends langium.AstNode {
  readonly $container: CreationBody | MessageBody;
  readonly $type: "Assignment";
  assignee: string;
  type?: string;
}

export const Assignment = "Assignment";

export function isAssignment(item: unknown): item is Assignment {
  return reflection.isInstance(item, Assignment);
}

export interface AsyncMessage extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "AsyncMessage";
  arrow?: "-" | "->";
  content?: string;
  from?: string;
  to: string;
}

export const AsyncMessage = "AsyncMessage";

export function isAsyncMessage(item: unknown): item is AsyncMessage {
  return reflection.isInstance(item, AsyncMessage);
}

export interface BinaryExpr extends langium.AstNode {
  readonly $container:
    | BinaryExpr
    | ConditionalExpression
    | Parameters
    | Primary;
  readonly $type: "BinaryExpr";
  left: Primary;
  op: Operator;
  right: Expression;
}

export const BinaryExpr = "BinaryExpr";

export function isBinaryExpr(item: unknown): item is BinaryExpr {
  return reflection.isInstance(item, BinaryExpr);
}

export interface Block extends langium.AstNode {
  readonly $container: BraceBlock | Model;
  readonly $type: "Block";
  statements: Array<Statement>;
}

export const Block = "Block";

export function isBlock(item: unknown): item is Block {
  return reflection.isInstance(item, Block);
}

export interface BraceBlock extends langium.AstNode {
  readonly $container:
    | CatchBlock
    | Critical
    | ElseBlock
    | ElseIfBlock
    | FinallyBlock
    | IfBlock
    | Loop
    | Message
    | Opt
    | Par
    | Ref
    | Section
    | TryBlock;
  readonly $type: "BraceBlock";
  block?: Block;
}

export const BraceBlock = "BraceBlock";

export function isBraceBlock(item: unknown): item is BraceBlock {
  return reflection.isInstance(item, BraceBlock);
}

export interface CatchBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "CatchBlock";
  block: BraceBlock;
  exception: string;
}

export const CatchBlock = "CatchBlock";

export function isCatchBlock(item: unknown): item is CatchBlock {
  return reflection.isInstance(item, CatchBlock);
}

export interface Comment extends langium.AstNode {
  readonly $type: "Comment";
  content?: string;
}

export const Comment = "Comment";

export function isComment(item: unknown): item is Comment {
  return reflection.isInstance(item, Comment);
}

export interface ConditionalExpression extends langium.AstNode {
  readonly $container: ElseIfBlock | IfBlock | Loop;
  readonly $type: "ConditionalExpression";
  condition?: Expression;
}

export const ConditionalExpression = "ConditionalExpression";

export function isConditionalExpression(
  item: unknown,
): item is ConditionalExpression {
  return reflection.isInstance(item, ConditionalExpression);
}

export interface Creation extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Creation";
  body: CreationBody;
}

export const Creation = "Creation";

export function isCreation(item: unknown): item is Creation {
  return reflection.isInstance(item, Creation);
}

export interface CreationBody extends langium.AstNode {
  readonly $container: Creation;
  readonly $type: "CreationBody";
  assignment?: Assignment;
  construct: string;
  invocation: Invocation;
}

export const CreationBody = "CreationBody";

export function isCreationBody(item: unknown): item is CreationBody {
  return reflection.isInstance(item, CreationBody);
}

export interface Critical extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Critical";
  block: BraceBlock;
}

export const Critical = "Critical";

export function isCritical(item: unknown): item is Critical {
  return reflection.isInstance(item, Critical);
}

export interface Declaration extends langium.AstNode {
  readonly $container: Parameters;
  readonly $type: "Declaration";
  name: string;
  type: string;
}

export const Declaration = "Declaration";

export function isDeclaration(item: unknown): item is Declaration {
  return reflection.isInstance(item, Declaration);
}

export interface Divider extends langium.AstNode {
  readonly $type: "Divider";
  content?: string;
}

export const Divider = "Divider";

export function isDivider(item: unknown): item is Divider {
  return reflection.isInstance(item, Divider);
}

export interface ElseBlock extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "ElseBlock";
  block: BraceBlock;
}

export const ElseBlock = "ElseBlock";

export function isElseBlock(item: unknown): item is ElseBlock {
  return reflection.isInstance(item, ElseBlock);
}

export interface ElseIfBlock extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "ElseIfBlock";
  block: BraceBlock;
  condition?: ConditionalExpression;
}

export const ElseIfBlock = "ElseIfBlock";

export function isElseIfBlock(item: unknown): item is ElseIfBlock {
  return reflection.isInstance(item, ElseIfBlock);
}

export interface FinallyBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "FinallyBlock";
  block: BraceBlock;
}

export const FinallyBlock = "FinallyBlock";

export function isFinallyBlock(item: unknown): item is FinallyBlock {
  return reflection.isInstance(item, FinallyBlock);
}

export interface Func extends langium.AstNode {
  readonly $container: MessageBody;
  readonly $type: "Func";
  signature: Array<Signature>;
}

export const Func = "Func";

export function isFunc(item: unknown): item is Func {
  return reflection.isInstance(item, Func);
}

export interface Group extends langium.AstNode {
  readonly $container: Header;
  readonly $type: "Group";
  name?: Name;
  participants: Array<Participant>;
}

export const Group = "Group";

export function isGroup(item: unknown): item is Group {
  return reflection.isInstance(item, Group);
}

export interface Head extends langium.AstNode {
  readonly $type: "Head" | "StarterExpression";
  headers: Array<Header>;
}

export const Head = "Head";

export function isHead(item: unknown): item is Head {
  return reflection.isInstance(item, Head);
}

export interface Header extends langium.AstNode {
  readonly $container: Head;
  readonly $type: "Header";
  group?: Group;
  participant?: Participant;
}

export const Header = "Header";

export function isHeader(item: unknown): item is Header {
  return reflection.isInstance(item, Header);
}

export interface IfBlock extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "IfBlock";
  block: BraceBlock;
  condition?: ConditionalExpression;
}

export const IfBlock = "IfBlock";

export function isIfBlock(item: unknown): item is IfBlock {
  return reflection.isInstance(item, IfBlock);
}

export interface Invocation extends langium.AstNode {
  readonly $container: CreationBody | Signature;
  readonly $type: "Invocation";
  parameters?: Parameters;
}

export const Invocation = "Invocation";

export function isInvocation(item: unknown): item is Invocation {
  return reflection.isInstance(item, Invocation);
}

export interface Label extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "Label";
  name?: Name;
}

export const Label = "Label";

export function isLabel(item: unknown): item is Label {
  return reflection.isInstance(item, Label);
}

export interface Loop extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Loop";
  block?: BraceBlock;
  condition: ConditionalExpression;
}

export const Loop = "Loop";

export function isLoop(item: unknown): item is Loop {
  return reflection.isInstance(item, Loop);
}

export interface Message extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Message";
  block?: BraceBlock;
  body: MessageBody;
}

export const Message = "Message";

export function isMessage(item: unknown): item is Message {
  return reflection.isInstance(item, Message);
}

export interface MessageBody extends langium.AstNode {
  readonly $container: Message;
  readonly $type: "MessageBody";
  arrow?: "->";
  assignment: Assignment;
  from?: Name;
  func?: Func;
  to?: Name;
}

export const MessageBody = "MessageBody";

export function isMessageBody(item: unknown): item is MessageBody {
  return reflection.isInstance(item, MessageBody);
}

export interface Model extends langium.AstNode {
  readonly $type: "Model";
  blocks: Array<Block>;
  head?: Head;
  title?: Title;
}

export const Model = "Model";

export function isModel(item: unknown): item is Model {
  return reflection.isInstance(item, Model);
}

export interface Name extends langium.AstNode {
  readonly $container:
    | Group
    | Label
    | MessageBody
    | Participant
    | Signature
    | StarterExpression
    | Stereotype;
  readonly $type: "Name";
  value: string;
}

export const Name = "Name";

export function isName(item: unknown): item is Name {
  return reflection.isInstance(item, Name);
}

export interface Opt extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Opt";
  block: BraceBlock;
}

export const Opt = "Opt";

export function isOpt(item: unknown): item is Opt {
  return reflection.isInstance(item, Opt);
}

export interface Par extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Par";
  block: BraceBlock;
}

export const Par = "Par";

export function isPar(item: unknown): item is Par {
  return reflection.isInstance(item, Par);
}

export interface Parameters extends langium.AstNode {
  readonly $container: Invocation;
  readonly $type: "Parameters";
  parameter: Array<Parameter>;
}

export const Parameters = "Parameters";

export function isParameters(item: unknown): item is Parameters {
  return reflection.isInstance(item, Parameters);
}

export interface Participant extends langium.AstNode {
  readonly $container: Group | Header;
  readonly $type: "Participant";
  label?: Label;
  name: Name;
  stereotype?: Stereotype;
  type?: ParticipantType;
}

export const Participant = "Participant";

export function isParticipant(item: unknown): item is Participant {
  return reflection.isInstance(item, Participant);
}

export interface ParticipantType extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "ParticipantType";
  type: string;
}

export const ParticipantType = "ParticipantType";

export function isParticipantType(item: unknown): item is ParticipantType {
  return reflection.isInstance(item, ParticipantType);
}

export interface Primary extends langium.AstNode {
  readonly $type: "Literal" | "Primary" | "Reference";
  expr: Expression;
}

export const Primary = "Primary";

export function isPrimary(item: unknown): item is Primary {
  return reflection.isInstance(item, Primary);
}

export interface Ref extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Ref";
  block: BraceBlock;
}

export const Ref = "Ref";

export function isRef(item: unknown): item is Ref {
  return reflection.isInstance(item, Ref);
}

export interface Section extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "Section";
  block: BraceBlock;
}

export const Section = "Section";

export function isSection(item: unknown): item is Section {
  return reflection.isInstance(item, Section);
}

export interface Signature extends langium.AstNode {
  readonly $container: Func;
  readonly $type: "Signature";
  invocation?: Invocation;
  methodName: Name;
}

export const Signature = "Signature";

export function isSignature(item: unknown): item is Signature {
  return reflection.isInstance(item, Signature);
}

export interface Stereotype extends langium.AstNode {
  readonly $container: Participant;
  readonly $type: "Stereotype";
  name: Name;
}

export const Stereotype = "Stereotype";

export function isStereotype(item: unknown): item is Stereotype {
  return reflection.isInstance(item, Stereotype);
}

export interface TCF extends langium.AstNode {
  readonly $container: Block;
  readonly $type: "TCF";
  catch?: CatchBlock;
  finally?: FinallyBlock;
  try: TryBlock;
}

export const TCF = "TCF";

export function isTCF(item: unknown): item is TCF {
  return reflection.isInstance(item, TCF);
}

export interface Title extends langium.AstNode {
  readonly $container: Model;
  readonly $type: "Title";
  content: string;
}

export const Title = "Title";

export function isTitle(item: unknown): item is Title {
  return reflection.isInstance(item, Title);
}

export interface TryBlock extends langium.AstNode {
  readonly $container: TCF;
  readonly $type: "TryBlock";
  block: BraceBlock;
}

export const TryBlock = "TryBlock";

export function isTryBlock(item: unknown): item is TryBlock {
  return reflection.isInstance(item, TryBlock);
}

export interface Width extends langium.AstNode {
  readonly $type: "Width";
  value: string;
}

export const Width = "Width";

export function isWidth(item: unknown): item is Width {
  return reflection.isInstance(item, Width);
}

export interface StarterExpression extends Head {
  readonly $type: "StarterExpression";
  annotation?: string;
  name?: Name;
}

export const StarterExpression = "StarterExpression";

export function isStarterExpression(item: unknown): item is StarterExpression {
  return reflection.isInstance(item, StarterExpression);
}

export interface Literal extends Primary {
  readonly $type: "Literal";
  value: string;
}

export const Literal = "Literal";

export function isLiteral(item: unknown): item is Literal {
  return reflection.isInstance(item, Literal);
}

export interface Reference extends Primary {
  readonly $type: "Reference";
  ref: string;
}

export const Reference = "Reference";

export function isReference(item: unknown): item is Reference {
  return reflection.isInstance(item, Reference);
}

export type SequenceAstType = {
  Alt: Alt;
  Assignment: Assignment;
  AsyncMessage: AsyncMessage;
  BinaryExpr: BinaryExpr;
  Block: Block;
  BraceBlock: BraceBlock;
  CatchBlock: CatchBlock;
  Comment: Comment;
  ConditionalExpression: ConditionalExpression;
  Creation: Creation;
  CreationBody: CreationBody;
  Critical: Critical;
  Declaration: Declaration;
  Divider: Divider;
  ElseBlock: ElseBlock;
  ElseIfBlock: ElseIfBlock;
  Expression: Expression;
  FinallyBlock: FinallyBlock;
  Func: Func;
  Group: Group;
  Head: Head;
  Header: Header;
  IfBlock: IfBlock;
  Invocation: Invocation;
  Label: Label;
  Literal: Literal;
  Loop: Loop;
  Message: Message;
  MessageBody: MessageBody;
  Model: Model;
  Name: Name;
  Opt: Opt;
  Par: Par;
  Parameter: Parameter;
  Parameters: Parameters;
  Participant: Participant;
  ParticipantType: ParticipantType;
  Primary: Primary;
  Ref: Ref;
  Reference: Reference;
  Section: Section;
  Signature: Signature;
  StarterExpression: StarterExpression;
  Statement: Statement;
  Stereotype: Stereotype;
  TCF: TCF;
  Title: Title;
  TryBlock: TryBlock;
  Width: Width;
};

export class SequenceAstReflection extends langium.AbstractAstReflection {
  getAllTypes(): string[] {
    return [
      Alt,
      Assignment,
      AsyncMessage,
      BinaryExpr,
      Block,
      BraceBlock,
      CatchBlock,
      Comment,
      ConditionalExpression,
      Creation,
      CreationBody,
      Critical,
      Declaration,
      Divider,
      ElseBlock,
      ElseIfBlock,
      Expression,
      FinallyBlock,
      Func,
      Group,
      Head,
      Header,
      IfBlock,
      Invocation,
      Label,
      Literal,
      Loop,
      Message,
      MessageBody,
      Model,
      Name,
      Opt,
      Par,
      Parameter,
      Parameters,
      Participant,
      ParticipantType,
      Primary,
      Ref,
      Reference,
      Section,
      Signature,
      StarterExpression,
      Statement,
      Stereotype,
      TCF,
      Title,
      TryBlock,
      Width,
    ];
  }

  protected override computeIsSubtype(
    subtype: string,
    supertype: string,
  ): boolean {
    switch (subtype) {
      case Alt:
      case AsyncMessage:
      case Creation:
      case Critical:
      case Loop:
      case Message:
      case Opt:
      case Par:
      case Ref:
      case Section:
      case TCF: {
        return this.isSubtype(Statement, supertype);
      }
      case BinaryExpr:
      case Primary: {
        return this.isSubtype(Expression, supertype);
      }
      case Declaration:
      case Expression: {
        return this.isSubtype(Parameter, supertype);
      }
      case ElseBlock:
      case ElseIfBlock:
      case IfBlock: {
        return this.isSubtype(Alt, supertype);
      }
      case Literal:
      case Reference: {
        return this.isSubtype(Primary, supertype);
      }
      case StarterExpression: {
        return this.isSubtype(Head, supertype);
      }
      default: {
        return false;
      }
    }
  }

  getReferenceType(refInfo: langium.ReferenceInfo): string {
    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
    switch (referenceId) {
      default: {
        throw new Error(`${referenceId} is not a valid reference id.`);
      }
    }
  }

  getTypeMetaData(type: string): langium.TypeMetaData {
    switch (type) {
      case Assignment: {
        return {
          name: Assignment,
          properties: [{ name: "assignee" }, { name: "type" }],
        };
      }
      case AsyncMessage: {
        return {
          name: AsyncMessage,
          properties: [
            { name: "arrow" },
            { name: "content" },
            { name: "from" },
            { name: "to" },
          ],
        };
      }
      case BinaryExpr: {
        return {
          name: BinaryExpr,
          properties: [{ name: "left" }, { name: "op" }, { name: "right" }],
        };
      }
      case Block: {
        return {
          name: Block,
          properties: [{ name: "statements", defaultValue: [] }],
        };
      }
      case BraceBlock: {
        return {
          name: BraceBlock,
          properties: [{ name: "block" }],
        };
      }
      case CatchBlock: {
        return {
          name: CatchBlock,
          properties: [{ name: "block" }, { name: "exception" }],
        };
      }
      case Comment: {
        return {
          name: Comment,
          properties: [{ name: "content" }],
        };
      }
      case ConditionalExpression: {
        return {
          name: ConditionalExpression,
          properties: [{ name: "condition" }],
        };
      }
      case Creation: {
        return {
          name: Creation,
          properties: [{ name: "body" }],
        };
      }
      case CreationBody: {
        return {
          name: CreationBody,
          properties: [
            { name: "assignment" },
            { name: "construct" },
            { name: "invocation" },
          ],
        };
      }
      case Critical: {
        return {
          name: Critical,
          properties: [{ name: "block" }],
        };
      }
      case Declaration: {
        return {
          name: Declaration,
          properties: [{ name: "name" }, { name: "type" }],
        };
      }
      case Divider: {
        return {
          name: Divider,
          properties: [{ name: "content" }],
        };
      }
      case ElseBlock: {
        return {
          name: ElseBlock,
          properties: [{ name: "block" }],
        };
      }
      case ElseIfBlock: {
        return {
          name: ElseIfBlock,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case FinallyBlock: {
        return {
          name: FinallyBlock,
          properties: [{ name: "block" }],
        };
      }
      case Func: {
        return {
          name: Func,
          properties: [{ name: "signature", defaultValue: [] }],
        };
      }
      case Group: {
        return {
          name: Group,
          properties: [
            { name: "name" },
            { name: "participants", defaultValue: [] },
          ],
        };
      }
      case Head: {
        return {
          name: Head,
          properties: [{ name: "headers", defaultValue: [] }],
        };
      }
      case Header: {
        return {
          name: Header,
          properties: [{ name: "group" }, { name: "participant" }],
        };
      }
      case IfBlock: {
        return {
          name: IfBlock,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case Invocation: {
        return {
          name: Invocation,
          properties: [{ name: "parameters" }],
        };
      }
      case Label: {
        return {
          name: Label,
          properties: [{ name: "name" }],
        };
      }
      case Loop: {
        return {
          name: Loop,
          properties: [{ name: "block" }, { name: "condition" }],
        };
      }
      case Message: {
        return {
          name: Message,
          properties: [{ name: "block" }, { name: "body" }],
        };
      }
      case MessageBody: {
        return {
          name: MessageBody,
          properties: [
            { name: "arrow" },
            { name: "assignment" },
            { name: "from" },
            { name: "func" },
            { name: "to" },
          ],
        };
      }
      case Model: {
        return {
          name: Model,
          properties: [
            { name: "blocks", defaultValue: [] },
            { name: "head" },
            { name: "title" },
          ],
        };
      }
      case Name: {
        return {
          name: Name,
          properties: [{ name: "value" }],
        };
      }
      case Opt: {
        return {
          name: Opt,
          properties: [{ name: "block" }],
        };
      }
      case Par: {
        return {
          name: Par,
          properties: [{ name: "block" }],
        };
      }
      case Parameters: {
        return {
          name: Parameters,
          properties: [{ name: "parameter", defaultValue: [] }],
        };
      }
      case Participant: {
        return {
          name: Participant,
          properties: [
            { name: "label" },
            { name: "name" },
            { name: "stereotype" },
            { name: "type" },
          ],
        };
      }
      case ParticipantType: {
        return {
          name: ParticipantType,
          properties: [{ name: "type" }],
        };
      }
      case Primary: {
        return {
          name: Primary,
          properties: [{ name: "expr" }],
        };
      }
      case Ref: {
        return {
          name: Ref,
          properties: [{ name: "block" }],
        };
      }
      case Section: {
        return {
          name: Section,
          properties: [{ name: "block" }],
        };
      }
      case Signature: {
        return {
          name: Signature,
          properties: [{ name: "invocation" }, { name: "methodName" }],
        };
      }
      case Stereotype: {
        return {
          name: Stereotype,
          properties: [{ name: "name" }],
        };
      }
      case TCF: {
        return {
          name: TCF,
          properties: [{ name: "catch" }, { name: "finally" }, { name: "try" }],
        };
      }
      case Title: {
        return {
          name: Title,
          properties: [{ name: "content" }],
        };
      }
      case TryBlock: {
        return {
          name: TryBlock,
          properties: [{ name: "block" }],
        };
      }
      case Width: {
        return {
          name: Width,
          properties: [{ name: "value" }],
        };
      }
      case StarterExpression: {
        return {
          name: StarterExpression,
          properties: [
            { name: "annotation" },
            { name: "headers", defaultValue: [] },
            { name: "name" },
          ],
        };
      }
      case Literal: {
        return {
          name: Literal,
          properties: [{ name: "expr" }, { name: "value" }],
        };
      }
      case Reference: {
        return {
          name: Reference,
          properties: [{ name: "expr" }, { name: "ref" }],
        };
      }
      default: {
        return {
          name: type,
          properties: [],
        };
      }
    }
  }
}

export const reflection = new SequenceAstReflection();
